% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gmapply.R
\name{gmapply}
\alias{gmapply}
\title{expand.grid-based multivariate apply (mapply) wrapper for fast implementation of nested looping structures}
\usage{
gmapply(mvars, FUN, SIMPLIFY = FALSE, ncores = NULL, ...)
}
\arguments{
\item{mvars}{a named list of variables to be combined and mapped over. These are equivalent to the layers of a nested for loop.}

\item{FUN}{user-defined function to apply over variables in mvars. N.B. This function is written to use the names of mvars as formal arguments to FUN. Thus, the majority of FUNs need not require any arguments to be specified. As long as the variable object names in FUN match the names of mvars,  gmapply will handle the translation of names(mvars) to FUN.}

\item{SIMPLIFY}{when set to TRUE, mimics the simplified output of Map to mapply.}

\item{ncores}{number of cores to utilize if running in parallel. This has not been fully vetted as of yet.}

\item{...}{}
}
\value{
compiled returns of FUN
}
\description{
expand.grid-based multivariate apply (mapply) wrapper for fast implementation of nested looping structures
}
\examples{

\dontrun{
     # Example 1:
     # just make sure variables used in your function appear as the names of mvars
     myfunc <- function(...){
       return_me <- paste(l3, l1^2 + l2, sep = "_")
       return(return_me)
     }

     mvars <- list(l1 = 1:10,
                   l2 = 1:5,
                   l3 = letters[1:3])

     gmapply(mvars, myfunc) # list output (mapply)
     lreturns <- gmapply(mvars, myfunc, SIMPLIFY = TRUE) # concatenated output (Map)

     # N.B. This is equivalent to running:
     lreturns <- c()
     for(l1 in 1:10){
       for(l2 in 1:5){
         for(l3 in letters[1:3]){
           lreturns <- c(lreturns,myfunc(l1,l2,l3))
         }
       }
     }



}

}
\author{
Nate Hall
}
